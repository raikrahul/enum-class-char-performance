<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body { margin: 0; padding: 20px; font-family: "Courier New", monospace; font-size: 13px; background: #f0f0f0; }
h1 { font-size: 18px; margin: 0 0 20px 0; }
h2 { font-size: 14px; margin: 20px 0 10px 0; }
p { margin: 10px 0; line-height: 1.6; }
pre { background: #e8e8e8; border: 1px solid #000; padding: 10px; margin: 10px 0; overflow-x: auto; line-height: 1.4; }
b { font-weight: bold; }
</style>
</head>
<body>

<h1>PROOF: enum class : char PERFORMANCE</h1>

<h2>AXIOM 1: Memory = array of bytes</h2>
<p>Memory is an array. Each cell holds one byte.</p>

<h2>AXIOM 2: int = 4 bytes</h2>
<p>C++ int type occupies 4 bytes in memory.</p>

<h2>AXIOM 3: char = 1 byte</h2>
<p>C++ char type occupies 1 byte in memory.</p>
<p>Ratio: int uses 4× memory of char.</p>

<h2>AXIOM 4: enum class default = int</h2>
<p>enum class without explicit underlying type uses int (4 bytes).</p>

<h2>AXIOM 5: enum class : char = char</h2>
<p>enum class with explicit underlying type : char uses char (1 byte).</p>

<h2>AXIOM 6: x86-64 move instructions</h2>
<p>movl = move 4 bytes</p>
<p>movb = move 1 byte</p>

<h2>DERIVATION 1: Assembly for enum</h2>
<p>Compile enum assignments to assembly.</p>
<p>int enum generates movl instruction.</p>
<p>char enum generates movb instruction.</p>

<h2>AXIOM 7: Machine code sizes</h2>
<p>movl encodes to 7 bytes.</p>
<p>movb encodes to 4 bytes.</p>
<p>Reduction: 42.8%</p>

<h2>AXIOM 8: Execution time same</h2>
<p>Both movl and movb execute in 1 cycle.</p>
<p>Instruction size difference: 42.8%</p>
<p>Performance impact: ~1-2%</p>

<h2>QUESTION</h2>
<p>If movb vs movl gives only 1-2% difference, why does benchmark show 3.53× speedup?</p>

<h2>AXIOM 9: operator&lt;&lt; overloads</h2>
<p>std::cout has different operator&lt;&lt; for int and char.</p>

<h2>DERIVATION 2: Function calls</h2>
<p>Printing int calls operator&lt;&lt;(int).</p>
<p>Printing char calls operator&lt;&lt;(char).</p>
<p>Different functions = different instruction counts.</p>

<h2>DERIVATION 3: Instruction count</h2>
<p>operator&lt;&lt;(int): ~50 instructions</p>
<p>- Check sign</p>
<p>- Division loop</p>
<p>- Modulo operations</p>
<p>- ASCII conversion</p>
<p>- Buffer writes</p>
<p></p>
<p>operator&lt;&lt;(char): ~10 instructions</p>
<p>- Check width</p>
<p>- Write byte</p>
<p>- Return</p>
<p></p>
<p>Ratio: 50 / 10 = 5.0×</p>

<h2>DERIVATION 4: Benchmark with cout</h2>
<p>10 million iterations.</p>
<p>int enum: 335ms average</p>
<p>char enum: 95ms average</p>
<p>Speedup: 3.53×</p>

<h2>DERIVATION 5: Explain ratio</h2>
<p>Total instructions per iteration:</p>
<p>int path: ~54 instructions</p>
<p>char path: ~14 instructions</p>
<p>Theoretical ratio: 54/14 = 3.857</p>
<p>Measured ratio: 3.53</p>
<p>Difference: 8.5% (measurement variance)</p>

<h2>CONCLUSION 1</h2>
<p>Speedup comes from operator&lt;&lt; function selection, NOT from movb vs movl.</p>
<p>movb vs movl: 1-2%</p>
<p>operator&lt;&lt;: 353%</p>

<h2>QUESTION</h2>
<p>What if no cout? Pure storage only?</p>

<h2>DERIVATION 6: Benchmark without cout</h2>
<p>100 million iterations.</p>
<p>int enum: 253.5ms average</p>
<p>char enum: 296.25ms average</p>
<p>char enum 17% SLOWER</p>

<h2>QUESTION</h2>
<p>Why is char enum slower without cout?</p>

<h2>DERIVATION 7: Ternary operator assembly</h2>
<p>Analyze: type = (i & 1) ? SELL : BUY;</p>
<p></p>
<p>int enum: 6 instructions, 0 branches, 0 stack ops</p>
<p>char enum: 11 instructions, 1 branch, 4 stack ops</p>

<h2>QUESTION</h2>
<p>Why does int use cmovnel but char uses jne?</p>

<h2>AXIOM 10: x86-64 cmov availability</h2>
<p>CMOVcc exists for 16-bit, 32-bit, 64-bit.</p>
<p>CMOVcc does NOT exist for 8-bit.</p>
<p></p>
<p>Compiler cannot use conditional move for char.</p>
<p>Compiler must use branch (jne) for char.</p>
<p>Compiler can use conditional move (cmovnel) for int.</p>

<h2>DERIVATION 8: Branch cost</h2>
<p>Branch misprediction penalty: 10-20 cycles</p>
<p>Pattern (i & 1): alternates 0,1,0,1...</p>
<p>Misprediction rate: 50%</p>
<p>Average cost per branch: 8 cycles</p>
<p>Stack operations: 12 cycles</p>
<p>Extra instructions: 5 cycles</p>
<p>Total extra cost: 25 cycles</p>

<h2>CONCLUSION 2</h2>
<p>Without cout, char enum is slower due to lack of 8-bit cmov.</p>
<p>int enum: uses cmovnel (no branch)</p>
<p>char enum: uses jne (branch + stack spills)</p>
<p>17% slower measured</p>

<h2>FINAL SUMMARY</h2>
<p><b>Storage:</b></p>
<p>int enum: 4 bytes</p>
<p>char enum: 1 byte</p>
<p>Reduction: 75%</p>
<p></p>
<p><b>Instruction encoding:</b></p>
<p>movl: 7 bytes</p>
<p>movb: 4 bytes</p>
<p>Reduction: 42.8%</p>
<p>Performance impact: 1-2%</p>
<p></p>
<p><b>With cout (10M iterations):</b></p>
<p>int enum: 335ms</p>
<p>char enum: 95ms</p>
<p>Speedup: 3.53×</p>
<p>Reason: operator&lt;&lt;(char) = 10 instructions vs operator&lt;&lt;(int) = 50 instructions</p>
<p></p>
<p><b>Without cout (100M iterations):</b></p>
<p>int enum: 253.5ms</p>
<p>char enum: 296.25ms</p>
<p>Slowdown: 17%</p>
<p>Reason: char uses branch because 8-bit cmov does not exist</p>
<p></p>
<p><b>PROOF COMPLETE</b></p>

<h2>SOURCE FILES</h2>
<p><a href="enum_storage.cpp" target="_blank">enum_storage.cpp</a></p>
<p><a href="test_enum.cpp" target="_blank">test_enum.cpp</a></p>
<p><a href="test_cout_int.cpp" target="_blank">test_cout_int.cpp</a></p>
<p><a href="test_cout_char.cpp" target="_blank">test_cout_char.cpp</a></p>
<p><a href="enum_benchmark.cpp" target="_blank">enum_benchmark.cpp</a></p>
<p><a href="pure_enum_test.cpp" target="_blank">pure_enum_test.cpp</a></p>

</body>
</html>
