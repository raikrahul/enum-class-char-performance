<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>enum class : char Performance Analysis</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: "Courier New", monospace; 
            font-size: 13px; 
            background: #e0e0e0; 
        }
        pre { 
            background: #d8d8d8; 
            border: 1px solid #000; 
            padding: 10px; 
            margin: 10px 0; 
            overflow-x: auto; 
            line-height: 1.4; 
        }
        hr { 
            border: 2px solid #000; 
            margin: 30px 0; 
        }
        a { 
            color: #000; 
            text-decoration: underline; 
        }
        a:hover { 
            background: #c0c0c0; 
        }
    </style>
</head>
<body>

<pre>
INTRODUCTION
</pre>

<pre>
enum class OrderType { BUY, SELL };
enum class OrderType2 : char { BUY='B', SELL='S' };
</pre>

<pre>
Two enum types.
First: default underlying type (int).
Second: explicit underlying type (char).
</pre>

<pre>
Measurements:
- sizeof operator
- Assembly instructions (movl vs movb)
- Machine code bytes
- Function calls (operator&lt;&lt;)
- Benchmark with cout (10M iterations)
- Benchmark without cout (100M iterations)
- Ternary operator assembly (cmovnel vs jne)
</pre>

<pre>
Compiler: clang++ 18.1.3
Flags: -std=c++23 -O0
Target: x86_64-pc-linux-gnu
</pre>

<pre>
All data from actual compilation and execution.
All assembly from .s files.
All timings from benchmark runs.
</pre>

<hr>

<pre>
LESSON 1: STORAGE SIZE
</pre>

<pre>
enum class OrderType { BUY, SELL };

OrderType type1 = OrderType::SELL;
</pre>

<pre>
sizeof(OrderType): 4
</pre>

<hr>

<pre>
LESSON 2: CHAR STORAGE SIZE
</pre>

<pre>
enum class OrderType2 : char { BUY='B', SELL='S' };

OrderType2 type2 = OrderType2::SELL;
</pre>

<pre>
sizeof(OrderType2): 1
</pre>

<hr>

<pre>
LESSON 3: ASCII VALUES
</pre>

<pre>
static_cast&lt;int&gt;('B') = 66
static_cast&lt;int&gt;('S') = 83
</pre>

<pre>
66 = 0x42
83 = 0x53
</pre>

<hr>

<pre>
LESSON 4: ASSEMBLY INSTRUCTION INT
</pre>

<pre>
AXIOM: Register
Register = storage location inside CPU.
%rbp = base pointer register (64-bit).
</pre>

<pre>
AXIOM: Stack
Stack = memory region for local variables.
Stack grows downward (higher addresses to lower addresses).
</pre>

<pre>
AXIOM: Stack Offset
-8(%rbp) = memory address 8 bytes below base pointer.
rbp = 0x7fff1000 (example)
rbp - 8 = 0x7fff0ff8
</pre>

<pre>
AXIOM: Immediate Value
$1 = literal value 1 (not a memory address).
</pre>

<pre>
AXIOM: movl Instruction
movl = move long (4 bytes).
movl SOURCE, DESTINATION
Copies 4 bytes from SOURCE to DESTINATION.
</pre>

<pre>
OrderType type = OrderType::SELL;
</pre>

<pre>
OrderType::SELL = 1
</pre>

<pre>
clang++ -std=c++23 -S -O0 enum_storage.cpp
</pre>

<pre>
movl    $1, -8(%rbp)
</pre>

<pre>
$1 = immediate value 1
-8(%rbp) = stack location 8 bytes below rbp
movl = copy 4 bytes
</pre>

<pre>
Action: Store value 1 (4 bytes) at memory address rbp-8
</pre>

<hr>

<pre>
LESSON 5: ASSEMBLY INSTRUCTION CHAR
</pre>

<pre>
AXIOM: movb Instruction
movb = move byte (1 byte).
movb SOURCE, DESTINATION
Copies 1 byte from SOURCE to DESTINATION.
</pre>

<pre>
OrderType2 type2 = OrderType2::SELL;
</pre>

<pre>
OrderType2::SELL = 'S' = 83
</pre>

<pre>
clang++ -std=c++23 -S -O0 enum_storage.cpp
</pre>

<pre>
movb    $83, -9(%rbp)
</pre>

<pre>
$83 = immediate value 83
-9(%rbp) = stack location 9 bytes below rbp
movb = copy 1 byte
</pre>

<pre>
Action: Store value 83 (1 byte) at memory address rbp-9
</pre>

<hr>

<pre>
LESSON 6: MACHINE CODE INT
</pre>

<pre>
AXIOM: Machine Code
Machine code = binary instructions CPU executes.
Displayed in hexadecimal.
</pre>

<pre>
AXIOM: Opcode
Opcode = operation code (first byte(s) of instruction).
Tells CPU what operation to perform.
</pre>

<pre>
AXIOM: Operands
Operands = data following opcode.
Specify addresses, registers, immediate values.
</pre>

<pre>
objdump -d test_enum
</pre>

<pre>
115f:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)
</pre>

<pre>
115f = memory address of instruction
c7 45 f8 01 00 00 00 = machine code bytes
movl $0x1,-0x8(%rbp) = assembly representation
</pre>

<pre>
c7 45 f8 01 00 00 00
</pre>

<pre>
byte 0: c7                        # movl opcode
byte 1: 45                        # ModR/M byte (addressing mode)
byte 2: f8                        # displacement -8 (0xf8 = -8 in two's complement)
byte 3: 01                        # immediate value byte 0
byte 4: 00                        # immediate value byte 1
byte 5: 00                        # immediate value byte 2
byte 6: 00                        # immediate value byte 3
</pre>

<pre>
0x01 00 00 00 = 1 in little-endian (least significant byte first)
</pre>

<pre>
7 bytes total
</pre>

<hr>

<pre>
LESSON 7: MACHINE CODE CHAR
</pre>

<pre>
objdump -d test_enum
</pre>

<pre>
1166:   c6 45 f7 53             movb   $0x53,-0x9(%rbp)
</pre>

<pre>
1166 = memory address of instruction
c6 45 f7 53 = machine code bytes
movb $0x53,-0x9(%rbp) = assembly representation
</pre>

<pre>
c6 45 f7 53
</pre>

<pre>
byte 0: c6                        # movb opcode
byte 1: 45                        # ModR/M byte (addressing mode)
byte 2: f7                        # displacement -9 (0xf7 = -9 in two's complement)
byte 3: 53                        # immediate value 83 (0x53 = 83)
</pre>

<pre>
4 bytes total
</pre>

<pre>
7 bytes (movl) - 4 bytes (movb) = 3 bytes difference
</pre>

<hr>

<pre>
LESSON 8: PRINT INT ENUM
</pre>

<pre>
AXIOM: Function Call
Function call = transfer control to another code location.
callq = call instruction (64-bit).
</pre>

<pre>
AXIOM: x86-64 Calling Convention
Parameter 1: %rdi register
Parameter 2: %rsi register
Parameter 3: %rdx register
(and so on)
</pre>

<pre>
AXIOM: this Pointer
Member function receives object address as first parameter.
std::cout is an object.
operator&lt;&lt; is a member function.
</pre>

<pre>
AXIOM: Name Mangling
C++ encodes function signatures in symbol names.
_ZNSolsEi = mangled name
c++filt = tool to demangle names
</pre>

<pre>
OrderType type = OrderType::BUY;
std::cout &lt;&lt; static_cast&lt;int&gt;(type);
</pre>

<pre>
OrderType::BUY = 0
</pre>

<pre>
clang++ -std=c++23 -S -O0 test_enum.cpp
</pre>

<pre>
movl    $0, -8(%rbp)                          # store enum value 0 on stack
movl    -8(%rbp), %esi                        # load value into esi (2nd parameter)
movq    _ZSt4cout@GOTPCREL(%rip), %rdi        # load cout address into rdi (1st parameter)
callq   _ZNSolsEi@PLT                         # call function
</pre>

<pre>
Step 1: Store 0 at stack location rbp-8
Step 2: Load value from rbp-8 into %esi (32-bit portion of %rsi)
Step 3: Load cout object address into %rdi
Step 4: Call function at _ZNSolsEi
</pre>

<pre>
c++filt _ZNSolsEi
</pre>

<pre>
std::ostream::operator&lt;&lt;(int)
</pre>

<pre>
Function signature: ostream&amp; operator&lt;&lt;(ostream* this, int value)
Parameter 1 (%rdi): this pointer (cout address)
Parameter 2 (%esi): int value (0)
</pre>

<hr>

<pre>
LESSON 9: PRINT CHAR ENUM
</pre>

<pre>
AXIOM: Sign Extension
movsbl = move with sign extension byte to long.
Copies 1 byte, extends to 4 bytes, preserving sign.
</pre>

<pre>
83 = 0x53 = 0b01010011
Sign bit (leftmost) = 0 (positive)
Extended to 32 bits: 0x00000053
</pre>

<pre>
OrderType2 type2 = OrderType2::SELL;
std::cout &lt;&lt; static_cast&lt;char&gt;(type2);
</pre>

<pre>
OrderType2::SELL = 'S' = 83
</pre>

<pre>
clang++ -std=c++23 -S -O0 test_enum.cpp
</pre>

<pre>
movb    $83, -9(%rbp)                         # store enum value 83 on stack
movsbl  -9(%rbp), %esi                        # load byte with sign extension into esi
movq    _ZSt4cout@GOTPCREL(%rip), %rdi        # load cout address into rdi
callq   _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c@PLT
</pre>

<pre>
Step 1: Store 83 at stack location rbp-9 (1 byte)
Step 2: Load 1 byte from rbp-9, extend to 4 bytes, store in %esi
Step 3: Load cout object address into %rdi
Step 4: Call function
</pre>

<pre>
c++filt _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
</pre>

<pre>
std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; 
std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;
(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char)
</pre>

<pre>
Function signature: ostream&amp; operator&lt;&lt;(ostream&amp; os, char c)
Parameter 1 (%rdi): ostream reference (cout address)
Parameter 2 (%esi): char value (83, extended to 32-bit)
</pre>

<hr>

<pre>
LESSON 10: BENCHMARK INT WITH COUT
</pre>

<pre>
for (int i = 0; i &lt; 10000000; ++i) {
    OrderType type = (i &amp; 1) ? OrderType::SELL : OrderType::BUY;
    null_stream &lt;&lt; static_cast&lt;int&gt;(type);
}
</pre>

<pre>
./enum_benchmark
</pre>

<pre>
Run 1: int enum (cast to int): 342 ms
Run 2: int enum (cast to int): 328 ms
Run 3: int enum (cast to int): 335 ms
</pre>

<pre>
(342 + 328 + 335) / 3 = 335
</pre>

<pre>
335 ms / 10000000 = 0.0000335 ms = 33.5 nanoseconds
</pre>

<hr>

<pre>
LESSON 11: BENCHMARK CHAR WITH COUT
</pre>

<pre>
for (int i = 0; i &lt; 10000000; ++i) {
    OrderType2 type = (i &amp; 1) ? OrderType2::SELL : OrderType2::BUY;
    null_stream &lt;&lt; static_cast&lt;char&gt;(type);
}
</pre>

<pre>
./enum_benchmark
</pre>

<pre>
Run 1: char enum (direct cast): 97 ms
Run 2: char enum (direct cast): 93 ms
Run 3: char enum (direct cast): 95 ms
</pre>

<pre>
(97 + 93 + 95) / 3 = 95
</pre>

<pre>
95 ms / 10000000 = 0.0000095 ms = 9.5 nanoseconds
</pre>

<hr>

<pre>
LESSON 12: RATIO WITH COUT
</pre>

<pre>
335 ms (int)
95 ms (char)
</pre>

<pre>
335 / 95 = 3.53
</pre>

<hr>

<pre>
LESSON 13: BENCHMARK INT WITHOUT COUT
</pre>

<pre>
for (int i = 0; i &lt; 100000000; ++i) {
    OrderType type = (i &amp; 1) ? OrderType::SELL : OrderType::BUY;
    sink_int = static_cast&lt;int&gt;(type);
}
</pre>

<pre>
./pure_enum_test
</pre>

<pre>
Run 1: int enum: 255 ms
Run 2: int enum: 254 ms
Run 3: int enum: 253 ms
Run 4: int enum: 252 ms
</pre>

<pre>
(255 + 254 + 253 + 252) / 4 = 254
</pre>

<pre>
254 ms / 100000000 = 0.00000254 ms = 2.54 nanoseconds
</pre>

<hr>

<pre>
LESSON 14: BENCHMARK CHAR WITHOUT COUT
</pre>

<pre>
for (int i = 0; i &lt; 100000000; ++i) {
    OrderType2 type = (i &amp; 1) ? OrderType2::SELL : OrderType2::BUY;
    sink_char = static_cast&lt;char&gt;(type);
}
</pre>

<pre>
./pure_enum_test
</pre>

<pre>
Run 1: char enum: 298 ms
Run 2: char enum: 298 ms
Run 3: char enum: 294 ms
Run 4: char enum: 295 ms
</pre>

<pre>
(298 + 298 + 294 + 295) / 4 = 296
</pre>

<pre>
296 ms / 100000000 = 0.00000296 ms = 2.96 nanoseconds
</pre>

<hr>

<pre>
LESSON 15: RATIO WITHOUT COUT
</pre>

<pre>
254 ms (int)
296 ms (char)
</pre>

<pre>
296 / 254 = 1.17
</pre>

<hr>

<pre>
LESSON 16: TERNARY CONDITION
</pre>

<pre>
AXIOM: Bitwise AND
&amp; = bitwise AND operator
Compares each bit position
1 &amp; 1 = 1
1 &amp; 0 = 0
0 &amp; 1 = 0
0 &amp; 0 = 0
</pre>

<pre>
i = 5
</pre>

<pre>
i &amp; 1 = 5 &amp; 1
</pre>

<pre>
5 = 0b0101
1 = 0b0001
</pre>

<pre>
  0b0101
&amp; 0b0001
  ------
  0b0001 = 1
</pre>

<pre>
AXIOM: Ternary Operator
condition ? value_if_true : value_if_false
If condition != 0, result = value_if_true
If condition == 0, result = value_if_false
</pre>

<pre>
1 != 0
</pre>

<pre>
Result: OrderType::SELL
</pre>

<hr>

<pre>
LESSON 17: TERNARY INT ASSEMBLY
</pre>

<pre>
AXIOM: CPU Flags
CPU has flags register with status bits.
ZF = Zero Flag
ZF = 1 if result is zero
ZF = 0 if result is non-zero
</pre>

<pre>
AXIOM: cmpl Instruction
cmpl = compare long (4 bytes)
cmpl SOURCE, DESTINATION
Performs: DESTINATION - SOURCE
Sets flags based on result
Does not store result
</pre>

<pre>
AXIOM: cmovnel Instruction
cmovnel = conditional move if not equal (long)
cmovnel SOURCE, DESTINATION
If ZF = 0: DESTINATION = SOURCE
If ZF = 1: DESTINATION unchanged
</pre>

<pre>
AXIOM: xorl Instruction
xorl = XOR long (4 bytes)
xorl %eax, %eax = %eax XOR %eax
Any value XOR itself = 0
Fast way to set register to 0
</pre>

<pre>
type = (i &amp; 1) ? OrderType::SELL : OrderType::BUY;
</pre>

<pre>
i = 5
OrderType::BUY = 0
OrderType::SELL = 1
</pre>

<pre>
clang++ -std=c++23 -S -O0 pure_enum_test.cpp
</pre>

<pre>
movl    -12(%rbp), %edx           # load i from stack into edx
andl    $1, %edx                  # edx = edx &amp; 1
xorl    %eax, %eax                # eax = 0
movl    $1, %ecx                  # ecx = 1
cmpl    $0, %edx                  # compare edx with 0, set flags
cmovnel %ecx, %eax                # if ZF=0, eax = ecx
movl    %eax, -16(%rbp)           # store result to stack
movl    -16(%rbp), %eax           # load result back
movl    %eax, sink_int(%rip)      # store to volatile variable
</pre>

<pre>
Step 1: edx = Memory[rbp-12] = 5
Step 2: edx = 5 &amp; 1 = 1
Step 3: eax = eax XOR eax = 0
Step 4: ecx = 1
Step 5: Compare: 1 - 0 = 1 (non-zero), ZF = 0
Step 6: ZF = 0 (not equal), eax = ecx = 1
Step 7: Memory[rbp-16] = 1
Step 8: eax = Memory[rbp-16] = 1
Step 9: Memory[sink_int] = 1
</pre>

<pre>
Instruction count:
1. movl
2. andl
3. xorl
4. movl
5. cmpl
6. cmovnel
7. movl
8. movl
9. movl
</pre>

<pre>
9 instructions
</pre>

<pre>
cmovnel = conditional move (no jump)
</pre>

<pre>
Branch count: 0
</pre>

<hr>

<pre>
LESSON 18: TERNARY CHAR ASSEMBLY
</pre>

<pre>
AXIOM: jne Instruction
jne = jump if not equal
jne LABEL
If ZF = 0: PC = address of LABEL
If ZF = 1: PC = next instruction
PC = Program Counter (instruction pointer)
</pre>

<pre>
AXIOM: Branch
Branch = instruction that changes PC based on condition.
Creates two possible execution paths.
CPU must predict which path to take.
</pre>

<pre>
AXIOM: Register Spilling
Spilling = storing register value to stack.
Happens when compiler runs out of registers.
</pre>

<pre>
AXIOM: x86-64 8-bit Registers
%al = low 8 bits of %rax
%dl = low 8 bits of %rdx
%cl = low 8 bits of %rcx
Limited number of 8-bit registers available
</pre>

<pre>
AXIOM: No cmovneb
x86-64 has cmovnel (32-bit conditional move)
x86-64 has cmovneq (64-bit conditional move)
x86-64 does NOT have cmovneb (8-bit conditional move)
Compiler must use branch for 8-bit values
</pre>

<pre>
type = (i &amp; 1) ? OrderType2::SELL : OrderType2::BUY;
</pre>

<pre>
i = 5
OrderType2::BUY = 'B' = 66
OrderType2::SELL = 'S' = 83
</pre>

<pre>
clang++ -std=c++23 -S -O0 pure_enum_test.cpp
</pre>

<pre>
movl    -12(%rbp), %ecx           # load i from stack into ecx
andl    $1, %ecx                  # ecx = ecx &amp; 1
movb    $83, %al                  # al = 83 (SELL)
movb    $66, %dl                  # dl = 66 (BUY)
movb    %dl, -42(%rbp)            # spill BUY to stack
cmpl    $0, %ecx                  # compare ecx with 0, set flags
movb    %al, -41(%rbp)            # spill SELL to stack
jne     .LBB4_6                   # if ZF=0, jump to .LBB4_6
movb    -42(%rbp), %al            # reload BUY from stack
movb    %al, -41(%rbp)            # store BUY to result location
.LBB4_6:                          # jump target label
movb    -41(%rbp), %al            # load result from stack
movb    %al, -13(%rbp)            # store to local variable
movb    -13(%rbp), %al            # load local variable back
movb    %al, sink_char(%rip)      # store to volatile variable
</pre>

<pre>
Step 1: ecx = Memory[rbp-12] = 5
Step 2: ecx = 5 &amp; 1 = 1
Step 3: al = 83
Step 4: dl = 66
Step 5: Memory[rbp-42] = 66 (spill BUY)
Step 6: Compare: 1 - 0 = 1 (non-zero), ZF = 0
Step 7: Memory[rbp-41] = 83 (spill SELL)
Step 8: ZF = 0 (not equal), PC jumps to .LBB4_6
Step 9: (skipped: instructions between jne and .LBB4_6)
Step 10: al = Memory[rbp-41] = 83
Step 11: Memory[rbp-13] = 83
Step 12: al = Memory[rbp-13] = 83
Step 13: Memory[sink_char] = 83
</pre>

<pre>
Instruction count:
1. movl
2. andl
3. movb
4. movb
5. movb
6. cmpl
7. movb
8. jne
9. movb (skipped in this execution)
10. movb (skipped in this execution)
11. movb
12. movb
13. movb
14. movb
</pre>

<pre>
14 instructions total (12 executed in this path)
</pre>

<pre>
jne = jump (branch instruction)
</pre>

<pre>
Branch count: 1
</pre>

<pre>
Stack operations:
Memory[rbp-42] = 66 (spill)
Memory[rbp-41] = 83 (spill)
Memory[rbp-13] = 83 (local variable)
Memory[sink_char] = 83 (volatile)
</pre>

<pre>
4 stack write operations
</pre>

<pre>
Comparison:
int enum: 9 instructions, 0 branches, cmovnel
char enum: 14 instructions, 1 branch, jne
</pre>

<hr>

<pre>
SOURCE CODE
</pre>

<pre>
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/enum_storage.cpp">enum_storage.cpp</a>         sizeof measurements
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/enum_storage.s">enum_storage.s</a>           assembly for sizeof test
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/test_enum.cpp">test_enum.cpp</a>            cout operator&lt;&lt; test
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/test_enum.s">test_enum.s</a>              assembly for cout test
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/enum_benchmark.cpp">enum_benchmark.cpp</a>       10M iterations with cout
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/pure_enum_test.cpp">pure_enum_test.cpp</a>       100M iterations without cout
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/pure_enum_test.s">pure_enum_test.s</a>         assembly for ternary operator
</pre>

<hr>

<pre>
WORKSHEETS
</pre>

<pre>
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/01-axioms-memory.md">01-axioms-memory.md</a>              sizeof measurements and ASCII values
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/02-assembly-instructions.md">02-assembly-instructions.md</a>      movl vs movb analysis
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/03-enum-storage-proof.md">03-enum-storage-proof.md</a>         storage verification
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/05-operator-int-assembly.md">05-operator-int-assembly.md</a>      operator&lt;&lt;(int) disassembly
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/06-operator-char-assembly.md">06-operator-char-assembly.md</a>     operator&lt;&lt;(char) disassembly
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/07-benchmark-methodology.md">07-benchmark-methodology.md</a>      benchmark setup
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/08-benchmark-results-proof.md">08-benchmark-results-proof.md</a>    timing measurements
<a href="https://github.com/raikrahul/enum-class-char-performance/blob/main/BRANCH_VS_CMOV_AXIOMS.md">BRANCH_VS_CMOV_AXIOMS.md</a>         cmovnel vs jne analysis
</pre>

<hr>

<pre>
REPRODUCTION
</pre>

<pre>
clang++ -std=c++23 enum_storage.cpp -o enum_storage
./enum_storage

clang++ -std=c++23 -S -O0 test_enum.cpp -o test_enum.s
clang++ -std=c++23 -O0 test_enum.cpp -o test_enum
objdump -d test_enum

clang++ -std=c++23 -O0 enum_benchmark.cpp -o enum_benchmark
./enum_benchmark

clang++ -std=c++23 -S -O0 pure_enum_test.cpp -o pure_enum_test.s
clang++ -std=c++23 -O0 pure_enum_test.cpp -o pure_enum_test
./pure_enum_test
</pre>

<hr>

<pre>
COMPILER
</pre>

<pre>
Ubuntu clang version 18.1.3 (1ubuntu1)
Target: x86_64-pc-linux-gnu
</pre>

</body>
</html>
